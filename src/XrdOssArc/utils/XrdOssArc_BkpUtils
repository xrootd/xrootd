#!/usr/bin/env python3
#******************************************************************************
#*                    X r d O s s A r c _ B k p U t i l s                    *
#******************************************************************************

import errno
import json
import os
import sys

from shutil import rmtree
from urllib.parse import urlparse

from rucio.client.didclient import DIDClient
from rucio.client.metaclient import MetaClient
from rucio.client.replicaclient import ReplicaClient

# Check for debugging
#
x = os.getenv("XRDOSSARC_DEBUG", None)
if x is None: Debug = False
else: Debug = True

# Initialize the did client
try:
   DIDclient = DIDClient()
except Exception as e:
   Emsg(8, "Error creating DID client: {}".format(e))
#******************************************************************************
#*                                  E m s g                                   *
#******************************************************************************
# Print to stderr a message
#
def Emsg(rc, txt):
   print('OssArc_BkupUtils:', txt, file=sys.stderr)
   if (rc < 0):
      print("Usage: addkey <key> [<key [...]]")
      print("       list   <key> <value> <scope> <eolval>")
      print("       qkey   <key>         <scope> <dsname>")
      print("       set    <key> <value> <scope> <dsname>")
      print("       setup  <rse> <scope> <dsname> <arenadir> <mountpfn>")
      rc = -rc
   if rc:
      sys.exit(rc)

#******************************************************************************
#*                                A d d K e y                                 *
#******************************************************************************

def AddKey(keys):
   metaclient = MetaClient()

   # Get all current keys
   #
   try:
      allkeys = metaclient.list_keys()
   except Exception as e:
         Emsg(8, 'Unable to list keys: {}'.format(key, e))

   # Add all missing keys
   #
   for key in keys:
      if not key in allkeys:
         try:
            metaclient.add_key(key=key, key_type='COLLECTION')
            if Debug: Emsg(0, "Metadata key '{}' added.".format(key))
         except Exception as e:
            Emsg(8, 'Unable to add key {}: {}'.format(key, e))
      elif Debug: Emsg(0, "Metadata key '{}' exists.".format(key))

   return True

#******************************************************************************
#*                              a r c S p l i t                               *
#******************************************************************************
  
def arcSplit(didVec, optSZ, minSZ, maxSZ):
   noGo = False
   vecSet = [] # Holds didVec grouped by conforming sizes
   vecMD  = [] # Holds medata description about vecSet

   # Now we try to group didVec entries to be about optSZ but not smaller
   # than maxSZ. Failure to do so is indicated by setting noGo to true.
   #
   curSize = 0
   curVec  = []
   while (len(didVec) > 0):
       didSZ = didVec[0][2]
       newSize = curSize + didSZ 
       if newSize < optSZ:
          curVec.append(didVec.pop(0))
          curSize = newSize
       elif newSize <= maxSZ:
          curVec.append(didVec.pop(0))
          vecSet.append(curVec)
          vecMD.append([len(curVec),newSize])
          curSize = 0
          curVec = []
       else:
          if len(curVec) == 0:
             noGo = True
             vecSet.append([didVec.pop(0)])
             vecMD.append([1, newSize])
          else:
             if curSize < minSZ:
                noGo = True
             vecSet.append(curVec)
             vecMD.append([len(curVec), curSize])
             curVec = []
             curSize = 0

   # Handle any residual memvec entries not included in vecSet. The residual
   # may create an additional vecSet member if it is conformable, or it may
   # be added to the last member of vecSet. Ideally, we would rebalance
   # vecSet to avoid violating maxSZ but better too large than too small.
   #
   if len(curVec) > 0:
      if curSize < minSZ:
         if len(vecSet) > 0:
            vsEnd = vecMD[-1]
            if vsEnd[1] + curSize > maxSZ:
               noGo = True
            vecMD[-1] = [vsEnd[0]+len(curVec), vsEnd[1] + curSize]
            for x in curVec: vecSet[-1].append(x)
         else:
            vecSet.append(curVec)
            vecMD.append([len(curVec), curSize])
      else:
         vecSet.append(curVec)
         vecMD.append([len(curVec), curSize])

   # Compute the ordinal metadata vector that can be used to locate which
   # set has the desired file using the original input file set.
   #
   if len(vecMD) > 1:
      ordN = vecMD[0][0]
      ordV = [ordN]
      for vsEnt in vecMD[1:-1]:
         ordN = ordN + vsEnt[0]
         ordV.append(ordN)
      ordMD = ' '.join(list(map(str, ordV)))
   else:
      ordMD = '' 
   return noGo, ordMD, vecSet, vecMD 
       
#******************************************************************************
#*                            a r c S y m l i n k                             *
#******************************************************************************
  
def arcSymlink(lfn2pfn, dsnDir, subDir=""):

   # If we need place the symlink in a subdirectory, create it, and chdir
   # to it, this is used when we are creating multiple archives.
   #
   if subDir: 
      if not os.path.exists(subDir):
         dsnDir = "{}/{}".format(dsnDir, subDir)
         try:
            os.mkdir(subDir)
         except Exception as e:
            Emsg(8, "Unable to create path {}: {}".format(dsnDir, e))
      try:
         os.chdir(subDir)
      except Exception as e:
          Emsg(errno.ENOENT, "Unable to chdir to {}: {}".format(dsnDir, e))

   # now create all the symlinks using the lfn pointing to the pfn
   #
   for fnMap in lfn2pfn:
      lfn  = fnMap[0]
      pfn  = fnMap[1]
      ldir = os.path.dirname(lfn)
      if ldir and lfn != '/':
         try:
            os.makedirs(ldir, 0o775, exist_ok=True)
         except Exception as e:
            Emsg(8, "Unable to recreate path {}{}: {}".format(dsnDir, ldir, e))
      try:
         os.symlink(pfn, lfn)
      except Exception as e:
         Emsg(8, "Unable to create symlink {} -> {}: {}".format(lfn,  pfn, e))

   # If we changed the current working directory, set it back to what it was
   #
   if subDir:
      try:
         os.chdir("..")
      except Exception as e:
          Emsg(errno.ENOENT, "Unable to chdir .. from {}: {}".format(dsnDir,e))

#******************************************************************************
#*                           G e t _ l f n 2 p f n                            *
#******************************************************************************

def Get_lfn2pfn(rse, scope, dsn, pfnPFX):

   if Debug: Emsg(0, 'list_files({}, {})'.format(scope,dsn))
   DIDclient = DIDClient()
   try:
      didVec = DIDclient.list_files(scope, dsn)
   except Exception as e:
      Emsg(8, "Error getting lfns: {}".format(e))

   # Convert an object list to a standard list so we can sort it.
   #
   lfnVec = []
   for file in didVec:
      lfnVec.append([file['scope'], file['name'], file['bytes']])

   # We must sort the lfns in order to be able to figure out which archive
   # the file was placed in should we need to spill over into multiple ones.
   # Also note that the sort key must include the scope due to collections.
   #
#  lfnVec.sort(key=lambda x: x['scope']+x['name'])
   lfnVec.sort(key=lambda x: x[0]+':'+x[1])

   qryVec = []
   sizVec = []
   totBytes = 0
   for file in lfnVec:
      qryVec.append({'scope':file[0], 'name':file[1]})
#     qryVec.append({'scope':file['scope'], 'name':file['name']})
#     sizVec.append(file['bytes'])
      sizVec.append(file[2])
      totBytes += file[2]
#     totBytes += file['bytes']
   totFiles = len(qryVec)

   # Get the replicas for the specified data
   lfn2pfn = []
   # print('PFN prefix:', pfnPFX)
   REPclient = ReplicaClient()

   # Get the maximum allowed items in a bulk query
   maxitems = 1000
   x = os.getenv("XRDOSSARC_MAXITEMS", None)
   if x is not None:
      try:
         maxitems = int(x)
         if maxitems < 1: maxitems = 1
      except Exception as e:
         Emsg(0, "XRDOSSARC_MAXITEMS={} is not an integer ({})".format(x, e))

   if Debug: Emsg(0, 'Rucio maxitems = {}'.format(maxitems))

   while (len(qryVec) > 0):
      try:
         replicas = REPclient.list_replicas(qryVec[0:min(len(qryVec), maxitems)], rse_expression=rse)
         for replica in replicas:
            pfn = pfnPFX + urlparse(replica["rses"][rse][0]).path
            did = qryVec.pop(0)
            siz = sizVec.pop(0)
            lfn2pfn.append([did['scope'] + ':' + did['name'], pfn, siz])
      except Exception as e:
         Emsg(8, "Error getting pfns: {}".format(e))
  
   if Debug:
      Emsg(0, 'DSN: {}:{} Files: {} Bytes: {}'.format(scope, dsn, totFiles,
                                                      totBytes))

   return totFiles, totBytes, lfn2pfn

#******************************************************************************
#*                               L S _ B k u p                                *
#******************************************************************************

def LS_Bkup(argv):

   # Make sure we have atleast four arguments. These would correspond to:
   # <key> <kval> <scope> <eol> 
   #
   if len(argv) < 4: Emsg(-errno.EINVAL, "Too few arguments") 
   key      = argv[0] 
   kval     = argv[1]
   theScope = argv[2]
   eol      = argv[3]

   try:
      dids = DIDclient.list_dids(scope=theScope, did_type='DIDType.DATASET',
                                 filters=({key:kval}), long=False)
   except Exception as e:
      Emsg(8, 'Cannot get datasets to be backed up: {}'.format(e))

   dsVec = []
   for did in dids:
      dsVec.append({'scope':theScope, 'name':did})

   # Get the metadata for all of the did's potentially needing backup
   #
   try:
      mVec = DIDclient.get_metadata_bulk(dsVec) 
   except Exception as e:
      Emsg(8, 'Cannot get dataset backup metadata: {}'.format(e))

   # Construct list of closed datasets as they can only be backed up
   #
   for meta in mVec:
      if not meta['is_open']:
         print(meta['name'])
      else:
         Emsg(0,"Dataset {}:{} is still open; backup skipped!".format(theScope,
                                                               meta['name']))

   print(eol)


#******************************************************************************
#*                               Q r y _ K e y                                *
#******************************************************************************

def Qry_Key(argv):

   # Make sure we have atleast three arguments. These would correspond to:
   # <key> <scope> <dsn> 
   #
   if len(argv) < 3: Emsg(-errno.EINVAL, "Too few arguments") 
   key      = argv[0] 
   theScope = argv[1]
   dsname   = argv[2]

   try:
       meta = DIDclient.get_metadata(theScope, dsname, 'JSON')
   except Exception as e:
      Emsg(8, "Unable to qury key {}: {}".format(key, e))

   print(meta.get(key))
   return True

#******************************************************************************
#*                            S e t _ B a c k u p                             *
#******************************************************************************

def Set_Backup(argv):

   # Make sure we have atleast four arguments. These would correspond to:
   # <key> <kval> <scope> <dsn> 
   #
   if len(argv) < 4: Emsg(-errno.EINVAL, "Too few arguments") 
   key      = argv[0] 
   kval     = argv[1]
   theScope = argv[2]
   dsname   = argv[3]
  
   try:
      DIDclient.set_metadata(theScope, dsname, key, kval)
   except Exception as e:
      {Emsg(8, "Unable to set {}:{} backup status to {}: {}".
               format(theScope, dsname, kval, e))
      }

   return True

#******************************************************************************
#*                               S e t _ K e y                                *
#******************************************************************************

def Set_Key(theScope, dsname, key, kval):
  
   try:
      DIDclient.set_metadata(theScope, dsname, key, kval)
   except Exception as e:
      Emsg(8, "Unable to set {}:{} metadata key {}: {}:".format(theScope,
              dsname, key, e))
  
#******************************************************************************
#*                                 S e t u p                                  *
#******************************************************************************
 
def Setup(argv):

   # Make sure we have atleast five arguments. These would correspond to:
   # <rse> <scope> <dsn> <path to atomic dsn directory> <pfn path prefix>
   #
   if len(argv) < 5: Emsg(-errno.EINVAL, "Too few arguments") 
   
   # Assign names to the arguments. Note that the dsnDir is atomically unique.
   #
   theRSE   = argv[0]
   theScope = argv[1]
   theDSN   = argv[2]
   dsnDir   = argv[3]
   pfnPFX   = argv[4]

   # Fix up pfn prefix as it must not end with a slash
   #
   while pfnPFX.endswith('/'): pfnPFX = pfnPFX[:-1]

   # Fix up dsnDir as it must not end with a slash
   #
   while dsnDir.endswith('/'): dsnDir = dsnDir[:-1]

   # Do some debugging
   #
   if Debug:
      Emsg(0, "RSE={} dsn={}:{} dsnDir={} pfnPFX={}".format(theRSE, theScope,
                                                     theDSN, dsnDir, pfnPFX))
   
   # Set out working directory to the root of the dataset members
   #
   try:
      os.chdir(dsnDir)
   except Exception as e:
      Emsg(errno.ENOENT, "unable to chdir to {}: {}".format(dsnDir,e))

   # Verify that we can use the target directory
   #  
   if (not os.access(dsnDir, os.W_OK)):
      Emsg(errno.EACCES, "{} not writable (target directory)".format(dsnDir))

   # Clean this directory of anything that might be left over. We remove the
   # last directory in the 
   #
   bStat = os.stat(dsnDir)
   bMode = bStat.st_mode & 0o777
   try:
      os.chdir('..')
      rmtree(dsnDir)
   except Exception as e:
      Emsg(8, "Unable to clean arena directory {}: {}".format(dsnDir, e))
   try:
      os.mkdir(dsnDir, bMode)
   except Exception as e:
      Emsg(8, "Unable to recreate arena directory {}: {}".format(dsnDir, e))
   try:
      os.chdir(dsnDir)
   except Exception as e:
      Emsg(8, "Unable to cd to arena directory {}: {}".format(dsnDir, e))

   # Obtain lfn to pfn map for the dataset
   #
   totFiles, totBytes, lfn2pfn = Get_lfn2pfn(theRSE, theScope, theDSN, pfnPFX)
     
   # Make sure we have something here to work with
   #
   if totFiles != len(lfn2pfn) or not totFiles:
      Emsg(errno.ENODATA, "Dataset {}:{} is empty!".format(theScope, theDSN))

   # Check if we want to possibly split this archive into segments
   #
   x = os.getenv("XRDOSSARC_SIZE", None)
   if x is not None:
      try:
         nparms = x.split()
         if len(nparms) < 4:
            Emsg(errno.EINVAL,"XRDOSSARC_SIZE={} has too few args!").format(x)
         wantSZ = int(nparms[0])
         aminSZ = int(nparms[1])
         amaxSZ = int(nparms[2])
         doSkip = int(nparms[3])
      except Exception as e:
         Emsg(errno.EINVAL,"XRDOSSARC_SIZE={} has non-integers ({})".format(x,e))
   else:
      amaxSZ = None
      doSkip = False

   if Debug: Emsg(0, 'XRDOSSARC_SIZE = {}'.format(x))

   # If split archives allowed, perform the split as requested
   #
   if amaxSZ:
      noGo, ordMD, arcSet, arcMD = arcSplit(lfn2pfn,wantSZ,aminSZ,amaxSZ)
      if noGo and doSkip:
         Set_Backup("arcBackup", "Skip", theScope, theDSN)
         {Emsg(16,"Unable to split {}:{} into conforming archives; skipping")
                   .format(theScope, theDSN)
         }
      Set_Key(theScope, theDSN, "arcIndex", ordMD)
      numArcs = len(arcMD)
      arcNum = 0
      for arcFiles in arcSet: 
          arcNum = arcNum + 1
          subDir = "~{}".format(arcNum)
          arcSymlink(arcFiles, dsnDir, subDir)
          arcEnt = arcMD.pop(0)
          if Debug:
             {Emsg(0, "Created {} symlinks in {}/{} for {} bytes".
                       format(arcEnt[0], dsnDir, subDir, arcEnt[1]))
             }
   else:
      numArcs = 1
      arcSymlink(lfn2pfn, dsnDir, '~1')

   # We are done, tell caller how big the setup is
   #
   {Emsg(0, "Setup {} {}:{} for {} archive(s) totalling {} files and {} bytes".
            format(theRSE, theScope, theDSN, numArcs, totFiles, totBytes))
   }

   print(totFiles, totBytes)
   return(0)

#******************************************************************************
#*                                  M a i n                                   *
#******************************************************************************

# The actual guts of the script
#
def Main(argv):

   # Make sure we have the common arguments: <cmd> <metakey> <metaval> <scope>
   # Normally, we would use argparse but that's left for another day.
   #
   if len(argv) < 1:
      Emsg(-errno.EINVAL, "Command not specified") 
      return errno.EINVAL
   cmd = argv[0]

   # There must be atleast one argument left
   #
   #
   if len(argv) < 2: Emsg(-errno.EINVAL, "Too few arguments") 

   # Check for setup as it has special arguments
   #
   if cmd == 'setup': return Setup(argv[1:])

   # Process the command
   #
   if (cmd == "addkey"):                   
      AddKey(argv[1:])
      return 0

   if (cmd == "list"):                   
      LS_Bkup(argv[1:])
      return 0

   if (cmd == "qkey"):
      Qry_Key(argv[1:])
      return 0

   if (cmd == "set"):
      Set_Backup(argv[1:])
      return 0
      
   # Unknown command
   #
   Emsg(-errno.EINVAL, "Unknown command, '{}'".format(cmd))
   return errno.EINVAL

if __name__ == "__main__":
   sys.exit(Main(sys.argv[1:]))
